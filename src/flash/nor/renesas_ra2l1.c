// SPDX-License-Identifier: GPL-2.0-or-later
//
// OpenOCD flash driver for Renesas RA2L1 (RV40-F flash)
//
// Basic verification done on RA2L1 (R7FA2L1AB3CFx): Code Flash 256KB, Data Flash 8KB
// Reference manual: RA2L1 User's Manual R01UH0853EJ0150 Rev.1.50 (2024-08-30)
//
// Notes:
//  - Code Flash erase unit 2KB, programming unit 32bit
//  - Data Flash erase unit 1KB, programming unit 8bit
//  - Data Flash read window 0x40100000, P/E window 0xFE000000
//  - FLCN base address 0x407EC000
//
// Write strategy:
//  1) On entering write(), first do pre-comparison by blocks in "read window", skip if entire block is identical
//  2) Merge consecutive blocks that need update into "segments", enter P/E once per segment, within segment: erase first, then continuous programming per block
//  3) Poll FRDY / FSTATR2, no fixed delays
//
// Author: TaterLi

#include "imp.h"
#include "helper/time_support.h"
#include "target/target.h"
#include "target/register.h"
#include "flash/nor/core.h"
#include <stdlib.h>
#include <string.h>
#include "target/algorithm.h"     /* init_reg_param / destroy_reg_param / target_run_algorithm */
#include "target/armv7m.h"        /* struct armv7m_algorithm / ARMV7M_COMMON_MAGIC */
#include "target/arm.h"           /* 某些版本需要这个才能拿到 ARM_MODE_THUMB */
#include "helper/binarybuffer.h"  /* buf_set_u32 / buf_get_u32 */
#include "helper/log.h"
#include <inttypes.h>

#define LOG_PREFIX "ra2l1"

// Register map (offsets from FLCN base)
#define FLCN_BASE 0x407EC000U
#define REG_DFLCTL (FLCN_BASE + 0x0090)  // Data Flash Control
#define REG_PFBER (FLCN_BASE + 0x3FC8)   // Prefetch Buffer Enable
#define REG_FENTRYR (FLCN_BASE + 0x3FB0) // P/E mode entry
#define REG_FPMCR (FLCN_BASE + 0x0100)   // Mode Control
#define REG_FPR (FLCN_BASE + 0x0180)     // Protection Unlock
#define REG_FCR (FLCN_BASE + 0x0114)     // Command Register
#define REG_FRESETR (FLCN_BASE + 0x0124) // Error Reset
#define REG_FISR (FLCN_BASE + 0x01D8)    // Frequency/Startup Area
#define REG_FSARH (FLCN_BASE + 0x0110)   // Start Addr High
#define REG_FSARL (FLCN_BASE + 0x0108)   // Start Addr Low
#define REG_FEARH (FLCN_BASE + 0x0120)   // End Addr High
#define REG_FEARL (FLCN_BASE + 0x0118)   // End Addr Low
#define REG_FWBH0 (FLCN_BASE + 0x0138)   // Write Buffer High (code)
#define REG_FWBL0 (FLCN_BASE + 0x0130)   // Write Buffer Low  (code & data)
#define REG_FSTATR1 (FLCN_BASE + 0x012C) // Status 1 (FRDY)
#define REG_FSTATR2 (FLCN_BASE + 0x01F0) // Status 2 (ERR)
#define REG_FEAML (FLCN_BASE + 0x01E0)   // Error Address Low
#define REG_FEAMH (FLCN_BASE + 0x01E8)   // Error Address High
#define REG_FPSR (FLCN_BASE + 0x0184)    // Protection Status


#define FENTRY_CODE_PE 0xAA01
#define FENTRY_DATA_PE 0xAA80
#define FENTRY_READ 0xAA00

// FCR commands
#define FCR_CMD_PROGRAM 0x81
#define FCR_CMD_END1 0x01
#define FCR_CMD_END0 0x00
#define FCR_CMD_ERASE_SEQ 0x84 // erase sequence init
#define FCR_CMD_ERASE 0x04     // block erase
#define FCR_CMD_BLANKCHK 0x83

// FPMCR mode bits (need to write FPR=0xA5 to unlock before writing)
#define FPMCR_CODE_PE 0x02 // program/erase mode for code
#define FPMCR_DATA_PE 0x10 // program/erase mode for data
#define FPMCR_READ 0x08    // read mode

// Status bits
#define FSTATR1_FRDY (1U << 6)    // Flash ready
#define FSTATR2_ERERR (1U << 0)   // Erase error
#define FSTATR2_PRGERR (1U << 1)  // Program error
#define FSTATR2_BCERR (1U << 3)   // Blank check error
#define FSTATR2_ILGLERR (1U << 4) // Illegal command/error

// Data flash control
#define DFLCTL_DFLEN (1U << 0) // Data flash enable

// Unique ID and Part Number registers
#define REG_UIDR(n) (0x01001C00u + ((n) * 4)) // Unique ID words
#define REG_PNR(n) (0x01001C10u + ((n) * 4))  // Part Number ASCII
#define REG_MCUVER 0x01001C20u                // MCU Version

// SYSC: Clock / Power registers
#define SYSC_BASE 0x4001E000u
#define REG_PRCR (SYSC_BASE + 0x3FEu) // Protect register
#define PRCR_PRC0 (1u << 0)
#define PRCR_PRC1 (1u << 1)
#define PRCR_KEY_A5 (0xA5u << 8)

#define REG_SCKDIVCR (SYSC_BASE + 0x020u) // Clock div register
#define REG_SCKSCR (SYSC_BASE + 0x026u)   // Clock source select
#define REG_MEMWAIT (SYSC_BASE + 0x031u)  // Memory wait control
#define REG_HOCOCR (SYSC_BASE + 0x036u)   // HOCO control
#define REG_MOCOCR (SYSC_BASE + 0x038u)   // MOCO control
#define REG_OSCSF (SYSC_BASE + 0x03Cu)    // Oscillation flags
#define REG_OPCCR (SYSC_BASE + 0x0A0u)    // Operation power mode

// SCKSCR CKSEL: 0=HOCO, 1=MOCO (only these two are used here)
#define CKSEL_HOCO 0x00u
#define CKSEL_MOCO 0x01u

// SCKDIVCR ICK field
#define SCKDIVCR_ICK_Pos 24
#define SCKDIVCR_ICK_Msk (0x7u << SCKDIVCR_ICK_Pos)

// FISR.PCKA encoding for 8MHz operation
#define FISR_PCKA_8MHZ 0b000111

#define ARM_MODE_THUMB 0x00000020u

struct ra2l1_flash_bank
{
    uint32_t pe_base; // P/E window base
    bool is_data;     // true: data flash
};

static unsigned char ra2l1_stub_bin[] = {
  0x72, 0xb6, 0x03, 0x4b, 0x9d, 0x46, 0x00, 0xf0, 0xa1, 0xf9, 0xab, 0xbe,
  0xfe, 0xe7, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x20, 0x40, 0xf2, 0xf0, 0x13,
  0x08, 0x4a, 0x00, 0x20, 0xd2, 0x58, 0xda, 0x3b, 0xff, 0x3b, 0x1a, 0x42,
  0x08, 0xd0, 0x01, 0x21, 0x05, 0x4b, 0x03, 0x38, 0x9a, 0x6a, 0x0a, 0x43,
  0x9a, 0x62, 0x9a, 0x6a, 0x8a, 0x43, 0x9a, 0x62, 0x70, 0x47, 0xc0, 0x46,
  0x00, 0xc0, 0x7e, 0x40, 0xfc, 0xc0, 0x7e, 0x40, 0x0e, 0x4a, 0x43, 0x1e,
  0x59, 0x18, 0x03, 0x0c, 0x10, 0xb5, 0x80, 0xb2, 0x53, 0x82, 0x0c, 0x4b,
  0x50, 0x81, 0x08, 0x0c, 0x89, 0xb2, 0x58, 0x62, 0x51, 0x83, 0x84, 0x21,
  0x09, 0x4a, 0x51, 0x75, 0x19, 0x6b, 0x49, 0x06, 0xfc, 0xd5, 0x04, 0x21,
  0x51, 0x75, 0x00, 0x21, 0x51, 0x75, 0x1a, 0x6b, 0x52, 0x06, 0xfc, 0xd4,
  0xff, 0xf7, 0xcc, 0xff, 0x10, 0xbd, 0xc0, 0x46, 0xfe, 0xc0, 0x7e, 0x40,
  0xfc, 0xc0, 0x7e, 0x40, 0xff, 0xc0, 0x7e, 0x40, 0x28, 0x23, 0x82, 0xb0,
  0x01, 0x93, 0x01, 0x9b, 0x5a, 0x1e, 0x01, 0x92, 0x0b, 0xb9, 0x02, 0xb0,
  0x70, 0x47, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xf4, 0xe7,
  0x43, 0xf6, 0xb2, 0x73, 0x10, 0xb5, 0x09, 0x4a, 0x09, 0x4c, 0xe2, 0x52,
  0xff, 0xf7, 0xea, 0xff, 0x40, 0xf2, 0x80, 0x13, 0xa5, 0x22, 0xe2, 0x50,
  0x71, 0x3b, 0xff, 0x34, 0xff, 0x3b, 0x4a, 0x32, 0x63, 0x70, 0x62, 0x70,
  0x63, 0x70, 0xff, 0xf7, 0xdd, 0xff, 0x10, 0xbd, 0x80, 0xaa, 0xff, 0xff,
  0x00, 0xc0, 0x7e, 0x40, 0x40, 0xf2, 0x80, 0x13, 0xa5, 0x22, 0x10, 0xb5,
  0x07, 0x4c, 0xf7, 0x21, 0xe2, 0x50, 0x23, 0x00, 0x9d, 0x3a, 0xff, 0x33,
  0x5a, 0x70, 0x59, 0x70, 0x5a, 0x70, 0xff, 0xf7, 0xc9, 0xff, 0x43, 0xf6,
  0xb2, 0x73, 0x02, 0x4a, 0xe2, 0x52, 0x10, 0xbd, 0x00, 0xc0, 0x7e, 0x40,
  0x00, 0xaa, 0xff, 0xff, 0x70, 0xb5, 0xe9, 0xb1, 0x85, 0x0a, 0x01, 0x38,
  0x44, 0x18, 0x40, 0xf2, 0x00, 0x46, 0xff, 0xf7, 0xc5, 0xff, 0xa4, 0x0a,
  0xad, 0x02, 0xa4, 0x02, 0xfe, 0x23, 0x1b, 0x06, 0x31, 0x00, 0xe8, 0x18,
  0xff, 0xf7, 0x8a, 0xff, 0x20, 0xb1, 0xff, 0xf7, 0xd3, 0xff, 0x03, 0x20,
  0x40, 0x42, 0x70, 0xbd, 0xa5, 0x42, 0x03, 0xd0, 0x40, 0xf2, 0x00, 0x43,
  0xed, 0x18, 0xed, 0xe7, 0xff, 0xf7, 0xc8, 0xff, 0x00, 0x20, 0xf4, 0xe7,
  0x70, 0xb5, 0x00, 0x29, 0x2b, 0xd0, 0x43, 0xf6, 0xb2, 0x72, 0xc5, 0x0a,
  0x01, 0x38, 0x15, 0x4b, 0x44, 0x18, 0x15, 0x49, 0x40, 0xf6, 0x00, 0x06,
  0x99, 0x52, 0x40, 0xf2, 0x80, 0x12, 0xa5, 0x21, 0x99, 0x50, 0x12, 0x4b,
  0x7f, 0x3a, 0xff, 0x3a, 0x58, 0x31, 0x5a, 0x70, 0x59, 0x70, 0x5a, 0x70,
  0xff, 0xf7, 0x84, 0xff, 0xe4, 0x0a, 0xed, 0x02, 0xe4, 0x02, 0x31, 0x00,
  0x28, 0x00, 0xff, 0xf7, 0x59, 0xff, 0x20, 0xb1, 0xff, 0xf7, 0xa2, 0xff,
  0x03, 0x20, 0x40, 0x42, 0x70, 0xbd, 0xa5, 0x42, 0x03, 0xd0, 0x40, 0xf6,
  0x00, 0x03, 0xed, 0x18, 0xef, 0xe7, 0xff, 0xf7, 0x97, 0xff, 0x00, 0x20,
  0xf4, 0xe7, 0xc0, 0x46, 0x00, 0xc0, 0x7e, 0x40, 0x01, 0xaa, 0xff, 0xff,
  0xff, 0xc0, 0x7e, 0x40, 0x05, 0x4b, 0x10, 0xb5, 0xc3, 0x18, 0x00, 0x20,
  0x90, 0x42, 0x00, 0xd1, 0x10, 0xbd, 0x1c, 0x18, 0x24, 0x78, 0x0c, 0x54,
  0x01, 0x30, 0xf7, 0xe7, 0x00, 0x00, 0x10, 0x40, 0x03, 0x00, 0x00, 0x20,
  0x10, 0xb5, 0x90, 0x42, 0x00, 0xd1, 0x10, 0xbd, 0xc4, 0x18, 0x24, 0x78,
  0x0c, 0x54, 0x01, 0x30, 0xf7, 0xe7, 0x00, 0x00, 0xf8, 0xb5, 0x0c, 0x00,
  0x16, 0x00, 0x0d, 0x00, 0x29, 0xb3, 0x00, 0x25, 0x1a, 0xb3, 0xfe, 0x23,
  0x01, 0x27, 0x1b, 0x06, 0xc5, 0x18, 0xff, 0xf7, 0x4d, 0xff, 0x11, 0x4b,
  0x2a, 0x0c, 0xad, 0xb2, 0x5a, 0x82, 0xa6, 0x19, 0x5d, 0x81, 0x81, 0x21,
  0x23, 0x78, 0x0e, 0x4a, 0x53, 0x63, 0x0e, 0x4b, 0x59, 0x75, 0x11, 0x6b,
  0x49, 0x06, 0xfc, 0xd5, 0x00, 0x21, 0x5f, 0x75, 0x59, 0x75, 0x13, 0x6b,
  0x5b, 0x06, 0xfc, 0xd4, 0xff, 0xf7, 0xec, 0xfe, 0x05, 0x00, 0x30, 0xb9,
  0x01, 0x34, 0xb4, 0x42, 0xe9, 0xd1, 0xff, 0xf7, 0x49, 0xff, 0x28, 0x00,
  0xf8, 0xbd, 0x03, 0x25, 0x6d, 0x42, 0xf8, 0xe7, 0xfe, 0xc0, 0x7e, 0x40,
  0xfc, 0xc0, 0x7e, 0x40, 0xff, 0xc0, 0x7e, 0x40, 0xf0, 0xb5, 0x87, 0xb0,
  0x0d, 0x00, 0x0f, 0x00, 0x05, 0x90, 0x01, 0x92, 0x00, 0x29, 0x59, 0xd0,
  0x00, 0x27, 0x00, 0x2a, 0x56, 0xd0, 0x43, 0xf6, 0xb2, 0x72, 0x2f, 0x4b,
  0x2f, 0x49, 0x30, 0x4e, 0x99, 0x52, 0x40, 0xf2, 0x80, 0x12, 0xa5, 0x21,
  0x99, 0x50, 0x02, 0x23, 0x83, 0x3a, 0x73, 0x70, 0x72, 0x70, 0x73, 0x70,
  0xff, 0xf7, 0xfa, 0xfe, 0x3c, 0x00, 0x01, 0x9b, 0x18, 0x1b, 0x02, 0x90,
  0x04, 0x28, 0x01, 0xd9, 0x04, 0x23, 0x02, 0x93, 0x2b, 0x5d, 0x04, 0x93,
  0x01, 0x28, 0x3c, 0xd0, 0xff, 0x22, 0x2f, 0x19, 0x7b, 0x78, 0x11, 0x00,
  0x03, 0x93, 0x02, 0x28, 0x03, 0xd0, 0xb9, 0x78, 0x03, 0x28, 0x00, 0xd0,
  0xfa, 0x78, 0x05, 0x98, 0x00, 0x19, 0x87, 0x07, 0x31, 0xd1, 0x07, 0x0c,
  0xbc, 0x46, 0x63, 0x46, 0x1b, 0x4f, 0x09, 0x04, 0x7b, 0x82, 0x03, 0x9b,
  0x12, 0x06, 0x1b, 0x02, 0x0b, 0x43, 0x04, 0x99, 0x80, 0xb2, 0x0b, 0x43,
  0x17, 0x49, 0x1a, 0x43, 0x9b, 0xb2, 0x78, 0x81, 0x4b, 0x63, 0x81, 0x23,
  0x12, 0x0c, 0xca, 0x63, 0x73, 0x75, 0x0b, 0x6b, 0x5b, 0x06, 0xfc, 0xd5,
  0x01, 0x23, 0x73, 0x75, 0x00, 0x23, 0x73, 0x75, 0x0b, 0x6b, 0x5b, 0x06,
  0xfc, 0xd4, 0xff, 0xf7, 0x81, 0xfe, 0x07, 0x00, 0x68, 0xb9, 0x02, 0x9b,
  0xe4, 0x18, 0x01, 0x9b, 0xa3, 0x42, 0xbc, 0xd8, 0xff, 0xf7, 0xdc, 0xfe,
  0x38, 0x00, 0x07, 0xb0, 0xf0, 0xbd, 0xff, 0x22, 0x11, 0x00, 0x03, 0x92,
  0xc9, 0xe7, 0x03, 0x27, 0x7f, 0x42, 0xf3, 0xe7, 0x00, 0xc0, 0x7e, 0x40,
  0x01, 0xaa, 0xff, 0xff, 0xff, 0xc0, 0x7e, 0x40, 0xfe, 0xc0, 0x7e, 0x40,
  0xfc, 0xc0, 0x7e, 0x40, 0x10, 0xb5, 0x00, 0xf0, 0x01, 0xf8, 0x10, 0xbd,
  0xf8, 0xb5, 0x40, 0xf2, 0xfe, 0x33, 0x0d, 0x00, 0x16, 0x00, 0x34, 0x49,
  0x34, 0x4a, 0x04, 0x00, 0xd1, 0x52, 0x01, 0x21, 0x33, 0x48, 0x34, 0x4f,
  0x01, 0x70, 0x43, 0xf6, 0xc8, 0x70, 0x39, 0x54, 0x32, 0x49, 0xd1, 0x52,
  0x32, 0x4b, 0x9c, 0x42, 0x30, 0xd9, 0x16, 0xb9, 0x05, 0x20, 0x40, 0x42,
  0x01, 0xe0, 0x0d, 0xb9, 0x00, 0x20, 0xf8, 0xbd, 0x2e, 0x4b, 0xe4, 0x18,
  0x41, 0xf6, 0xff, 0x73, 0x9c, 0x42, 0x48, 0xd8, 0x42, 0xf2, 0x00, 0x02,
  0x2b, 0x19, 0x93, 0x42, 0x43, 0xd8, 0x29, 0x00, 0x20, 0x00, 0xff, 0xf7,
  0xb1, 0xfe, 0x08, 0xb1, 0x04, 0x20, 0xe8, 0xe7, 0x2a, 0x00, 0x31, 0x00,
  0x20, 0x00, 0xff, 0xf7, 0x1d, 0xff, 0x07, 0x00, 0x00, 0x28, 0xdf, 0xd1,
  0x2a, 0x00, 0x20, 0x00, 0x21, 0x49, 0xff, 0xf7, 0xfb, 0xfe, 0x20, 0x4b,
  0xf1, 0x5d, 0xfa, 0x5c, 0x91, 0x42, 0x03, 0xd1, 0x01, 0x37, 0xbd, 0x42,
  0xf8, 0xd1, 0xd5, 0xe7, 0x06, 0x20, 0xd0, 0xe7, 0x00, 0x2d, 0xd1, 0xd0,
  0x80, 0x23, 0xdb, 0x02, 0x9c, 0x42, 0x1e, 0xd2, 0x62, 0x19, 0x9a, 0x42,
  0x1b, 0xd8, 0x29, 0x00, 0x20, 0x00, 0xff, 0xf7, 0xab, 0xfe, 0x00, 0x28,
  0xd6, 0xd1, 0x2a, 0x00, 0x31, 0x00, 0x20, 0x00, 0xff, 0xf7, 0x2c, 0xff,
  0x07, 0x00, 0x00, 0x28, 0xb8, 0xd1, 0x2a, 0x00, 0x20, 0x00, 0x0e, 0x49,
  0xff, 0xf7, 0xe2, 0xfe, 0x0c, 0x4b, 0xf1, 0x5d, 0xfa, 0x5c, 0x91, 0x42,
  0xdc, 0xd1, 0x01, 0x37, 0xbd, 0x42, 0xf8, 0xd1, 0xae, 0xe7, 0x02, 0x20,
  0xa9, 0xe7, 0xc0, 0x46, 0x03, 0xa5, 0xff, 0xff, 0x00, 0xe0, 0x01, 0x40,
  0x90, 0xc0, 0x7e, 0x40, 0x00, 0xc0, 0x7e, 0x40, 0x00, 0xa5, 0xff, 0xff,
  0xff, 0xff, 0x0f, 0x40, 0x00, 0x00, 0xf0, 0xbf, 0x00, 0x30, 0x00, 0x20
};

unsigned int ra2l1_stub_bin_len = 1104;

/* ====== 固定内存布局（与链接脚本一致） ====== */
#define RA2L1_STUB_BASE    0x20006000u
#define RA2L1_STUB_SIZE    0x00002000u  /* 保险：不小于 .text 实际大小 */
#define RA2L1_STUB_ENTRY   (RA2L1_STUB_BASE | 1u)  /* Thumb 入口 */
#define RA2L1_STUB_SP      0x20007C00u

#define RA2L1_WORKBUF      0x20000100u   /* 主机→目标数据暂存区（避开 DUMP_ADDR 与 stub） */
#define RA2L1_CHUNK_MAX    0x2000u       /* 8 KB：保证不与 DUMP_ADDR(0x20003000) 与 stub(0x20006000) 重叠 */
#define RA2L1_CHUNK_MIN    0x0100u

#define RA2L1_BKPT_NUM     0xAB          /* 与 stub 内 BKPT #0xAB 对齐 */


static int ra2l1_run_stub_chunk(struct target *target,
				uint32_t dst_abs,
				const uint8_t *src_host,
				uint32_t len)
{
	int retval;

	/* 把本片数据拷到目标 RAM */
	retval = target_write_buffer(target, RA2L1_WORKBUF, len, src_host);
	if (retval != ERROR_OK) {
		LOG_ERROR("RA2L1: write workbuf failed (%d)", retval);
		return retval;
	}

	/* r0/r1/r2/sp 准备 */
	struct reg_param regs[4];
	init_reg_param(&regs[0], "r0", 32, PARAM_IN_OUT);
	init_reg_param(&regs[1], "r1", 32, PARAM_IN_OUT);
	init_reg_param(&regs[2], "r2", 32, PARAM_IN_OUT);
	init_reg_param(&regs[3], "sp", 32, PARAM_OUT);

	buf_set_u32(regs[0].value, 0, 32, dst_abs);
	buf_set_u32(regs[1].value, 0, 32, len);
	buf_set_u32(regs[2].value, 0, 32, RA2L1_WORKBUF);
	buf_set_u32(regs[3].value, 0, 32, RA2L1_STUB_SP);

	struct armv7m_algorithm algo;
	memset(&algo, 0, sizeof(algo));
	algo.common_magic = ARMV7M_COMMON_MAGIC;
	algo.core_mode    = ARM_MODE_THUMB;

	retval = target_run_algorithm(target,
		0, NULL,                 /* mem params */
		ARRAY_SIZE(regs), regs,  /* reg params */
		RA2L1_STUB_ENTRY, 0,     /* entry / exit unused (BKPT) */
		10000,                   /* timeout ms，可按片大小扩 */
		&algo);

	if (retval != ERROR_OK) {
		LOG_ERROR("RA2L1: stub run failed (%d) @0x%08" PRIx32 " len=%" PRIu32,
		          retval, dst_abs, len);
		goto out;
	}

	/* r0 = stub 返回码 */
	uint32_t stub_status = buf_get_u32(regs[0].value, 0, 32);
	if (stub_status != 0) {
		LOG_ERROR("RA2L1: stub status=0x%08" PRIx32 " @0x%08" PRIx32 " len=%" PRIu32,
		          stub_status, dst_abs, len);
		retval = (stub_status == (uint32_t)-6) ? ERROR_FAIL : ERROR_FLASH_OPERATION_FAILED;
	} else {
		retval = ERROR_OK;
	}

out:
	destroy_reg_param(&regs[0]);
	destroy_reg_param(&regs[1]);
	destroy_reg_param(&regs[2]);
	destroy_reg_param(&regs[3]);
	return retval;
}


// Utility: unlock/lock write protection register
static inline int ra2l1_unlock_prcr(struct target *t)
{
    return target_write_u16(t, REG_PRCR, PRCR_KEY_A5 | PRCR_PRC0 | PRCR_PRC1);
}

static inline int ra2l1_lock_prcr(struct target *t)
{
    return target_write_u16(t, REG_PRCR, PRCR_KEY_A5);
}


// Prefetch control
static inline int ra2l1_prefetch_enable(struct target *t, bool en)
{
    return target_write_u8(t, REG_PFBER, en ? 1 : 0);
}


// Device information (print only once)
static void ra2l1_read_chip_info(struct target *t)
{
    static bool printed = false;
    if (printed)
        return;
    printed = true;

    uint32_t uid[4], pn[4];
    uint8_t ver;

    for (int i = 0; i < 4; i++)
        target_read_u32(t, REG_UIDR(i), &uid[i]);

    for (int i = 0; i < 4; i++)
        target_read_u32(t, REG_PNR(i), &pn[i]);

    target_read_u8(t, REG_MCUVER, &ver);

    char part[17];
    memcpy(part, pn, 16);
    part[16] = '\0';

    LOG_INFO(LOG_PREFIX ": UID=%08" PRIx32 "%08" PRIx32 "%08" PRIx32 "%08" PRIx32,
             uid[0], uid[1], uid[2], uid[3]);
    LOG_INFO(LOG_PREFIX ": Part#='%s', Ver=0x%02x", part, ver);
}


/* ====== 对外：OpenOCD 写入口（替换 flash_driver 的 .write 回调） ====== */
static int ra2l1_flash_write(struct flash_bank *bank,
			     const uint8_t *buffer,
			     uint32_t offset,
			     uint32_t count)
{
	if (count == 0)
		return ERROR_OK;

	struct target *target = bank->target;
	int retval;

	/* 目标停机 */
	retval = target_halt(target);
	if (retval != ERROR_OK) return retval;
	retval = target_wait_state(target, TARGET_HALTED, 1000);
	if (retval != ERROR_OK) return retval;

	/* 写入 stub 到固定地址（与链接脚本一致） */
	if (ra2l1_stub_bin_len > RA2L1_STUB_SIZE) {
		LOG_ERROR("RA2L1: stub too large (%u > %u)",
		          ra2l1_stub_bin_len, RA2L1_STUB_SIZE);
		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
	}
	retval = target_write_buffer(target, RA2L1_STUB_BASE,
	                             ra2l1_stub_bin_len, ra2l1_stub_bin);
	if (retval != ERROR_OK) {
		LOG_ERROR("RA2L1: write stub @0x%08" PRIx32 " failed (%d)",
		          (uint32_t)RA2L1_STUB_BASE, retval);
		return retval;
	}

	/* 分片执行 stub：绝对地址 = bank->base + offset + off */
	uint32_t off = 0;
	while (off < count) {
		uint32_t chunk = count - off;
		if (chunk > RA2L1_CHUNK_MAX)
			chunk = RA2L1_CHUNK_MAX;

		uint32_t dst_abs = bank->base + offset + off;

		retval = ra2l1_run_stub_chunk(target, dst_abs, buffer + off, chunk);
		if (retval != ERROR_OK)
			return retval;

		off += chunk;
	}

	return ERROR_OK;
}


// Read
static int ra2l1_flash_read(struct flash_bank *bank, uint8_t *readbuf,
                            uint32_t offset, uint32_t count)
{
    return target_read_memory(bank->target, bank->base + offset, 1, count, readbuf);
}

// Erase interface (here delegate to write()'s segment flow, empty implementation is fine)
static int ra2l1_flash_erase(struct flash_bank *bank, unsigned first, unsigned last)
{
    // To reduce P/E entry/exit times, actual erase done in write path
    return ERROR_OK;
}

// Probe
static int ra2l1_flash_probe(struct flash_bank *bank)
{
    struct ra2l1_flash_bank *info = calloc(1, sizeof(*info));
    if (!info)
        return ERROR_FAIL;
    bank->driver_priv = info;

    if (bank->base == 0x40100000)
    {
        info->is_data = true;
        info->pe_base = 0xFE000000;
        bank->size = 8 * 1024;
        bank->num_sectors = 8;
    }
    else
    {
        info->is_data = false;
        info->pe_base = 0x00000000;
        bank->size = 256 * 1024;
        bank->num_sectors = bank->size / 2048;
    }

    bank->sectors = calloc(bank->num_sectors, sizeof(struct flash_sector));
    if (!bank->sectors)
        return ERROR_FAIL;

    for (unsigned i = 0; i < bank->num_sectors; i++)
    {
        bank->sectors[i].offset = i * (info->is_data ? 1024 : 2048);
        bank->sectors[i].size = (info->is_data ? 1024 : 2048);
    }

    if (!info->is_data)
        ra2l1_read_chip_info(bank->target);

    ra2l1_prefetch_enable(bank->target, false);
    target_write_u8(bank->target, REG_DFLCTL, DFLCTL_DFLEN);
    return ERROR_OK;
}

static int ra2l1_flash_auto_probe(struct flash_bank *bank)
{
    if (bank->target->state != TARGET_HALTED)
        return ERROR_TARGET_NOT_HALTED;
    return ra2l1_flash_probe(bank);
}

// OpenOCD commands
FLASH_BANK_COMMAND_HANDLER(ra2l1_flash_bank_command)
{
    // flash bank <name> ra2l1 <base> <size> <chip_width> <bus_width> <target>
    if (CMD_ARGC < 6)
        return ERROR_COMMAND_SYNTAX_ERROR;
    bank->base = strtoull(CMD_ARGV[1], NULL, 0);
    bank->size = strtoul(CMD_ARGV[2], NULL, 0);
    bank->chip_width = strtol(CMD_ARGV[3], NULL, 0);
    bank->bus_width = strtol(CMD_ARGV[4], NULL, 0);
    bank->target = get_target(CMD_ARGV[5]);
    if (!bank->target)
        return ERROR_FAIL;
    return ERROR_OK;
}

static const struct command_registration ra2l1_exec_command_handlers[] = {
    COMMAND_REGISTRATION_DONE};

const struct flash_driver ra2l1_flash = {
    .name = "ra2l1",
    .commands = ra2l1_exec_command_handlers,
    .flash_bank_command = ra2l1_flash_bank_command,
    .erase = ra2l1_flash_erase,
    .protect = NULL,
    .write = ra2l1_flash_write,
    .read = ra2l1_flash_read,
    .probe = ra2l1_flash_probe,
    .auto_probe = ra2l1_flash_auto_probe,
    .erase_check = default_flash_blank_check,
    .info = NULL,
};
